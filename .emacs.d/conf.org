* Start off with some highly [[https://github.com/hrs/sensible-defaults.el][sensible defaults]]
#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/bind-commenting-and-uncommenting)
  (sensible-defaults/backup-to-temp-directory)

  ;; Prevent outdated bytecode from being loaded
  (setq load-prefer-newer t)

  ;; Try to use UTF8 when possible
  (prefer-coding-system 'utf-8)

  ;; I use the setup here: https://gist.github.com/ChillingHsu/513f9d0333f03592576338f90bc2f898
  ;; to run railwaycat emacs as a server and open new files from the commandline with emacsclient
  (server-start)
#+END_SRC


* Set up use-package
** Make sure it's installed, and set some options
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  ;; Extra info in *Messages*
  (setq use-package-verbose t)

  ;; Download and install automatically if not found
  (setq use-package-always-ensure t)

  (eval-when-compile  ;; <-- Not sure what this is doing
    (require 'use-package))

  ;; use-package's keybinding macro
  (require 'bind-key)
#+END_SRC

** Prevent loading old bytecode with [[https://melpa.org/#/auto-compile][auto-compile]]
#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
#+END_SRC


* UI
** Hide toolbars, menus, frame maximization, etc
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (when window-system  ;; Will be nil if using emacs in terminal
    (scroll-bar-mode 0))
  ;; Disable all alarms
  (setq ring-bell-function 'ignore)

  ;; Custom function to toggle fullscreen on mac
  ;; This only works on railwaycat emacs
  ;; on railwaycat emacs you can just hold shift and
  ;; pinch in/out--I keep this around for when I'm
  ;; using a mouse instead of a trackpad
  (defun gw/mac-toggle-fullscreen ()
    (interactive)
    (set-frame-parameter nil 'fullscreen
      (if (frame-parameter nil 'fullscreen)
        nil
        'fullboth)))
#+END_SRC

** Narrower fringes
#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)  ; Default is 8
#+END_SRC
** Set default font and custom resize behavior
These custom scaling functions affect text EVERYWHERE, not just the current buffer.
#+BEGIN_SRC emacs-lisp
  (setq gw/default-font "Iosevka light")
  (setq gw/default-font-size 13)
  (setq gw/current-font-size gw/default-font-size)

  (setq gw/font-change-increment 1.1)

  (defun gw/font-code ()
    "Return a string representing the current font (like \"Input-12\")."
    (concat gw/default-font "-" (number-to-string gw/current-font-size)))

  (defun gw/set-font-size ()
    "Set the font to `gw/default-font' at `gw/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (gw/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun gw/reset-font-size ()
    "Change font size back to `gw/default-font-size'."
    (interactive)
    (setq gw/current-font-size gw/default-font-size)
    (gw/set-font-size))

  (defun gw/increase-font-size ()
    "Increase current font size by a factor of `gw/font-change-increment'."
    (interactive)
    (setq gw/current-font-size
          (ceiling (* gw/current-font-size gw/font-change-increment)))
    (gw/set-font-size))

  (defun gw/decrease-font-size ()
    "Decrease current font size by a factor of `gw/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq gw/current-font-size
          (max 1
               (floor (/ gw/current-font-size gw/font-change-increment))))
    (gw/set-font-size))

  (global-set-key (kbd "C-x C-+") 'gw/increase-font-size)
  (global-set-key (kbd "C-x C--") 'gw/decrease-font-size)

  (gw/reset-font-size)
#+END_SRC

** Slower mouse scrolling
#+BEGIN_SRC emacs-lisp
  ;; 2 lines per scroll instead of 5
  (setq mouse-wheel-scroll-amount '(2 ((shift) . 1) ((control) . nil)))

  ;; Don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC
** Solid cursor that's wide as glyph underneath
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (setq x-stretch-cursor 1)
#+END_SRC

** Pick a theme
#+BEGIN_SRC emacs-lisp
  ;; I use the default them during the day and zenburn at night
  ;; (use-package hc-zenburn-theme
  ;;   :config
  ;;   (load-theme 'hc-zenburn t))
#+END_SRC
** Org Mode
*** Syntax highlight code blocks
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC


* Indentation / tabs
** Never use tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Display tabs as 4 spaces wide
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

** Soft-wrap long lines in texty modes
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'turn-on-visual-line-mode)
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC

** Correctly indent soft-wrapped lines
#+BEGIN_SRC emacs-lisp
  (use-package adaptive-wrap
      :defer t  ; Needed b/c we're not using any of the implicit defer macros
      :init (add-hook 'visual-line-mode-hook 'adaptive-wrap-prefix-mode))
#+END_SRC
** Use dtrt-indent to auto-detect indentation in some modes
When enabled as a minor mode, it will transparently try to set the indentation offset and `indent-tabs-mode` if it confidently detect what the currently-edited file is doing. It's source code is well-documented-just read it if you're having trouble.
#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :defer t
    :init
    (add-hook 'prog-mode-hook 'dtrt-indent-mode)
    :config
    (setq dtrt-indent-verbosity 2))
#+END_SRC

    :config
    (setq dtrt-indent-verbosity 2)
    (dtrt-indent-mode t))
#+END_SRC


* Editing/Selecting Text
** Use "C-=": expand-region for easy semantic highlighting
This is the only non-Vim way I can live without "cib" and friends
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

** Auto-insert the other half of a pair
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
#+END_SRC
** Don't allow invisible edits in Org mode
It's easy to accidentally edit across folds--throw an error.
#+BEGIN_SRC emacs-lisp
  (setq org-catch-invisible-edits t)
#+END_SRC



* Languages
** YAML
*** Install yaml-mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")
#+END_SRC

** Ruby
*** Don't insert "coding: utf-8" magic comment
#+BEGIN_SRC emacs-lisp
  (setq ruby-insert-encoding-magic-comment nil)
#+END_SRC


* Autocomplete
** "M-/": hippie-expand instead of dabbrev-expand
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

** Configure Irony for C, C++, ObjC
** Configure Company and Company-Irony
#+BEGIN_SRC emacs-lisp
  (use-package company
    :defer t  ; Needed b/c we're not using any of the implicit defer macros
    :init (add-hook 'prog-mode-hook 'company-mode)  ; Load when activating a programming language mode
    :config
    (setq company-idle-delay 0.2)  ; In seconds--default is 0.5
    ; TAB to select candidate
    (bind-key "<tab>" 'company-complete-selection company-active-map)
    ; Don't complete on <enter>, just input a newline
    (unbind-key "<return>" company-active-map)
    (unbind-key "RET" company-active-map))
#+END_SRC
NB: successful completion of stuff in shared project header files requires setting `company-clang-arguments` (preferably in a .dir-locals.el) at project root to tell company about your header files for that project. For example:

`((nil . ((company-clang-arguments . ("-I/Users/grantwu/Code/git/lang/lilc/lib/")))))`

(I'm not putting it in a code block b/c I don't want this to be run on startup)

Read more about directory-local variables [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][here]].


* Buffers
** Use interactive buffer menu instead of default one
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Switch focus to new help buffers for easier <q> quitting
#+BEGIN_SRC emacs-lisp
  (setq-default help-window-select t)
#+END_SRC


* Point
** Save point location across sessions
#+BEGIN_SRC emacs-lisp
  (save-place-mode)
#+END_SRC


* Searching / Navigation
** Faster highlighting with incremental search
#+BEGIN_SRC emacs-lisp
  (setq lazy-highlight-initial-delay 0.06)
#+END_SRC
** More extensive apropos search
#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t)
#+END_SRC

** Show Speedbar in same frame
#+BEGIN_SRC emacs-lisp
  (use-package sr-speedbar)
#+END_SRC

** Show current match/total in modeline with isearch
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :config (global-anzu-mode))
#+END_SRC

** C-': Avy for "easymotion" behavior
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind
    ("C-'" . avy-goto-word-1)
    :config
    (setq avy-background t)  ; Grey background when displaying results
    (setq avy-keys
          '(
            ?t ?n ?s ?e ?r ?i ?o ?a  ;; 'power eight': can type them without any movement of the hand.
               ?w ?f ?l ?u ?y ?\; ?d ?h ?x ?c ?v ?m ?, ?. ;; close to home rows; no pinkes
               ?g ?b ?j ?k ?\' ;; diagonals, pinkie moves
               ?q ?z ?p ?\/ ;; pinkies away from the home row
               ;; ?4 ?7 ?3 ?8 ?9 ?2 ?5 ?1 ?6 ;; digits; in an order similar to the above
               ;; shifted letters come here ...
               ?T ?N ?S ?E ?R ?I ?A
               ?W ?F ?L ?U ?Y ?\: ?D ?H ?X ?C ?V ?M ?< ?> ;; close to home rows; no pinkes
               ;; These are too similar to be practical in the "fast jumping" context: ?0 ?O
               )))
#+END_SRC
** Install flx
For better fuzzy matching in Ivy
#+BEGIN_SRC emacs-lisp
  (use-package flx)
#+END_SRC
** Use Ivy, Swiper, and Counsel for minibuffer stuff
In MELPA, Ivy and Swiper are included as dependencies of Counsel, so we just have to install the latter.
Ivy provides a generic narrowing interface similar to (but simpler than) Helm. Swiper and Counsel both use Ivy--Swiper replaces `isearch`, and Counsel replaces most of the common minibuffer search interfaces--see below.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :config       ; Stuff that only has meaning after package is loaded (possibly deferred)
    (ido-mode 0)  ; Disable Ido
    (ivy-mode 1)  ; Enable Ivy
    (setq ivy-use-virtual-buffers t)       ; Include recent files and bookmarks in ivy-switch-buffer
    (setq counsel-find-file-ignore-regexp  ; Ignore stuff in find-file
          (concat  ; NB all backslashes must be double-escaped
           ;; Beginning with . or #
           "\\(?:\\`[#.]\\)"
           ;; Ending with ~ or #
           "\\|\\(?:[#~]\\'\\)"
           ;; Ending with .out
           "\\|\\(?:\\.out\\'\\)"
           ;; Ending with .dSYM/
           "\\|\\(?:\\.dSYM/\\'\\)"
           ;; __pycache__/
           "\\|\\(?:__pycache__/\\'\\)"
           ;; node_modules/
           "\\|\\(?:node_modules/\\'\\)"
           ))
    (setq ivy-re-builders-alist
          '((t . ivy--regex-plus)))  ; Multi-word non-fuzzy regex matching
    :bind
    ("C-x C-f" . counsel-find-file)  ; Respects counsel-find-file-ignore-regexp
    ("M-x" . counsel-M-x)            ; Shows keybindings in results
    ("C-x b" . ivy-switch-buffer)    ; Otherwise, uses normal non-ivy minibuffer until you M-x ivy-switch-buffer manually, once
    ("<f1> f" . counsel-describe-function)   ; Highlights interactive functions
    ("<f1> v" . counsel-describe-variable))  ; Highlights defcustoms

#+END_SRC

** Use Projectile for project management
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :demand  ; Override the deferral introduced by :bind to allow project switching at startup
    :config
    (setq projectile-completion-system 'ivy)
    (setq projectile-track-known-projects-automatically nil)  ; Don't auto-detect projects--it's noisy
    (setq projectile-enable-caching t)
    (projectile-mode))  ; Enable projectile-mode globally
#+END_SRC


* VC / Diffing


* Generic Keybindings / Custom Functions
** Emacs
*** Edit this file
#+BEGIN_SRC emacs-lisp
  (defun gw/edit-config ()
    (interactive)
    (find-file "~/.emacs.d/conf.org"))
#+END_SRC
*** Enable M- commands like M-h (highlight paragraph)
#+BEGIN_SRC emacs-lisp
  (setq mac-pass-command-to-system nil)
#+END_SRC
*** Swap Meta and Super so Meta is closer to thumb
#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
#+END_SRC
*** C-h: Backspace
Use <f1> to access help menus instead.
#+BEGIN_SRC emacs-lisp
  ;; Use key-translation-map to override any "C-h" bindings that any major or minor mode tries to introduce.
  (define-key key-translation-map (kbd "C-h") (kbd "<DEL>"))
#+END_SRC
*** C-w: Kill backwards word if region is not active
Since this uses `global-set-key` it can be overridden.
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-region-or-word (arg)
      "When called interactively with no region, kill a word backwards."
    (interactive "*p")
    (if (and transient-mark-mode
             mark-active)
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))

  (global-set-key (kbd "C-w") 'gw/kill-region-or-word)
#+END_SRC

*** M-<backspace>: Kill line backwards to indent
M-<backspace> kills backwards word by default, but that's duplicated by C-<backspace>, and also C-w above.
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-line-backwards-and-indent ()
    (interactive)
    (kill-line 0)
    (indent-according-to-mode))

  (global-set-key (kbd "M-<backspace>") 'gw/kill-line-backwards-and-indent)
#+END_SRC
*** C-x k: Kill current buffer without asking anything
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'gw/kill-current-buffer)
#+END_SRC

*** M-o: Focus other window
Default: add or remove faces to text in region
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
#+END_SRC

*** Switch windows when splitting
#+BEGIN_SRC emacs-lisp
  (defun gw/split-window-below-and-switch ()
    "Split window horizontally below and switch to new frame."
    (interactive)
    (split-window-below)
    (other-window 1))

  (defun gw/split-window-right-and-switch ()
    "Split window vertically to the right and switch to new frame."
    (interactive)
    (split-window-right)
    (other-window 1))

  (global-set-key (kbd "C-x 2") 'gw/split-window-below-and-switch)
  (global-set-key (kbd "C-x 3") 'gw/split-window-right-and-switch)
#+END_SRC


*** C-s: Swiper instead of forward-i-search
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s") 'counsel-grep-or-swiper)
#+END_SRC

** Org Mode
*** <el: Elisp source block template
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC


* History
** Persist kill-ring, isearch queries, and other minibuffer stuff across sessions
#+BEGIN_SRC emacs-lisp
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-delete-duplicates t)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC


* Useful Info
** global-set-key vs define-key
Use the former to define a global keymapping, use the latter to define a mapping for a particular mode, like so: `(define-key c-mode-base-map (kbd "C-c t") 'myfunc)`.

`c-mode-base-map` applies to all languages that cc-mode supports, whereas `c-mode-map` applies to just the C language.

`key-translation-map` is a lower-level mapping that basically modifies what keystrokes Emacs sees. `global-set-key` mappings are overridden by minor mode mappings--`key-translation-map` mappings are not.


* Stuff for future
- Set up automatic TAGS file loading when switching projects, instead of doing M-x visit-tags-table manually when switching projects.
- Make a globally-enabled minor mode for keybindings that should be active everywhere, like C-w
- Disable bold fonts after init, so it actually works (after everything else loads)
