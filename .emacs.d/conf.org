* Start off with some highly [[https://github.com/hrs/sensible-defaults.el][sensible defaults]]
#+BEGIN_SRC emacs-lisp
  (load-file "~/.emacs.d/sensible-defaults/sensible-defaults.el")
  (sensible-defaults/use-all-settings)
  (sensible-defaults/bind-commenting-and-uncommenting)
  (sensible-defaults/backup-to-temp-directory)

  ;; Prevent outdated bytecode from being loaded
  (setq load-prefer-newer t)

  ;; Try to use UTF8 when possible
  (prefer-coding-system 'utf-8)

  ;; Since I didn't compile Emacs from source, I have to download the source files separately
  ;; and point Emacs to it manually so that M-. knows where to look
  (setq find-function-C-source-directory "~/Code/git/emacs/src/")

  ;; I use the setup here: https://gist.github.com/ChillingHsu/513f9d0333f03592576338f90bc2f898
  ;; to run railwaycat emacs as a server and open new files from the commandline with emacsclient
  (server-start)
#+END_SRC


* Set up use-package
** Tips for using use-package
Macros
:init - Run /before/ package is loaded
:config - Run /after/ package is loaded

You almost never need :defer—these all imply :defer:
:commands, :bind, :bind*, :bind-keymap, :bind-keymap*, :mode, :interpreter, :hook.

** Make sure it's installed, and set some options
#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  ;; Extra info in *Messages*
  (setq use-package-verbose t)

  ;; Download and install automatically if not found
  (setq use-package-always-ensure t)

  (eval-when-compile  ;; <-- Not sure what this is doing
    (require 'use-package))

  ;; use-package's keybinding macro
  (require 'bind-key)
#+END_SRC

** Prevent loading old bytecode with [[https://melpa.org/#/auto-compile][auto-compile]]
#+BEGIN_SRC emacs-lisp
  (use-package auto-compile
    :config (auto-compile-on-load-mode))
#+END_SRC

** Enable diminishing modes
#+BEGIN_SRC emacs-lisp
  (use-package diminish
    :ensure t
    :diminish eldoc-mode
    :diminish visual-line-mode
    :diminish buffer-face-mode
    :diminish org-src-mode
    :diminish org-indent-mode)

  (with-eval-after-load 'subword
    (diminish 'subword-mode))

  (with-eval-after-load 'face-remap
    (diminish 'buffer-face-mode))

  (with-eval-after-load 'org-indent
    (diminish 'org-indent-mode))
#+END_SRC

* Custom defvars
#+BEGIN_SRC emacs-lisp
  (defvar gw/zettel-dir "~/icloud_drive/Documents/"
    "The directory to use when searching for notes / tags.")

  (defvar gw/zettel-dir-truename (file-truename gw/zettel-dir)
    "The value of gw/zettel-dir with symlinks resolved.")
#+END_SRC


* UI
** Hide toolbars, menus, frame maximization, etc
#+BEGIN_SRC emacs-lisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (when window-system  ;; Will be nil if using emacs in terminal
    (scroll-bar-mode 0))
  ;; Disable all alarms
  (setq ring-bell-function 'ignore)

  ;; Disable native tabs in Mac
  (setq mac-frame-tabbing nil)

  ;; Custom function to toggle fullscreen on mac
  ;; This only works on railwaycat emacs
  ;; on railwaycat emacs you can just hold shift and
  ;; pinch in/out—I keep this around for when I'm
  ;; using a mouse instead of a trackpad
  (defun gw/mac-toggle-fullscreen ()
    (interactive)
    (set-frame-parameter nil 'fullscreen
      (if (frame-parameter nil 'fullscreen)
        nil
        'fullboth)))
#+END_SRC

** Narrower fringes
#+BEGIN_SRC emacs-lisp
  (fringe-mode 4)  ; Default is 8
  ;; (add-hook 'prog-mode-hook (lambda () (setq left-fringe-width 4 right-fringe-width 4)))
#+END_SRC
** Set default font and custom resize behavior
These custom scaling functions affect text EVERYWHERE, not just the current buffer.
#+BEGIN_SRC emacs-lisp
  (setq gw/default-font "Iosevka Term SS04")
  (setq gw/default-font-size 15)
  (setq gw/current-font-size gw/default-font-size)

  (setq gw/font-change-increment 1.1)

  (defun gw/font-code ()
    "Return a string representing the current font (like \"Input-12\")."
    (concat gw/default-font "-" (number-to-string gw/current-font-size)))

  (defun gw/set-font-size ()
    "Set the font to `gw/default-font' at `gw/current-font-size'.
  Set that for the current frame, and also make it the default for
  other, future frames."
    (let ((font-code (gw/font-code)))
      (add-to-list 'default-frame-alist (cons 'font font-code))
      (set-frame-font font-code)))

  (defun gw/reset-font-size ()
    "Change font size back to `gw/default-font-size'."
    (interactive)
    (setq gw/current-font-size gw/default-font-size)
    (gw/set-font-size))

  (defun gw/increase-font-size ()
    "Increase current font size by a factor of `gw/font-change-increment'."
    (interactive)
    (setq gw/current-font-size
          (ceiling (* gw/current-font-size gw/font-change-increment)))
    (gw/set-font-size))

  (defun gw/decrease-font-size ()
    "Decrease current font size by a factor of `gw/font-change-increment', down to a minimum size of 1."
    (interactive)
    (setq gw/current-font-size
          (max 1
               (floor (/ gw/current-font-size gw/font-change-increment))))
    (gw/set-font-size))

  (global-set-key (kbd "C-x C-+") 'gw/increase-font-size)
  (global-set-key (kbd "C-x C--") 'gw/decrease-font-size)

  (gw/reset-font-size)
#+END_SRC

** Slower mouse scrolling
#+BEGIN_SRC emacs-lisp
  ;; 2 lines per scroll instead of 5
  (setq mouse-wheel-scroll-amount '(2 ((shift) . 1) ((control) . nil)))

  ;; Don't accelerate scrolling
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC
** Emulate vim scrolloff behavior
Default is to center point whenever scrolling off screen.
#+BEGIN_SRC emacs-lisp
  (setq scroll-step 1)
  (setq scroll-margin 5)
#+END_SRC

** Solid cursor that's wide as glyph underneath
#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 1)
  (setq x-stretch-cursor 1)
#+END_SRC

** Soft-wrap long lines in texty modes
#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-visual-line-mode)
#+END_SRC
** Function to temporarily maximize buffer
#+BEGIN_SRC emacs-lisp
  (defun gw/toggle-maximize-buffer ()
    "Temporarily maximize the buffer."
         (interactive)
         (if (= 1 (length (window-list)))
             (jump-to-register '_)
           (progn
             (window-configuration-to-register '_)
             (delete-other-windows))))

  ;; 'balance-windows is on "C-x +" by default but that sucks
  (global-set-key (kbd "C-x =") 'balance-windows)
  ;; TODO Display "ZOOM" in the mode line, or something
  (global-set-key (kbd "C-x +") 'gw/toggle-maximize-buffer)

  ;; Rebalance windows after adding / removing splits
  (defadvice split-window-right
      (after switch-and-balance activate)
    (other-window 1)
    (balance-windows))

  (defadvice split-window-below
      (after switch-and-balance activate)
    (other-window 1)
    (balance-windows))

  (defadvice delete-window
      (after rebalance activate)
    (balance-windows))

  (defadvice quit-window
      (after rebalance activate)
    (balance-windows))
#+END_SRC
** Org Mode
*** Hide emphasis markup
=//= - italic
=**= - bold
__ - underline
=~~= - code
== - verbatim (don't emphasize whatever's in there)
#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

*** Syntax highlight code blocks
#+BEGIN_SRC emacs-lisp
  (setq org-src-fontify-natively t)
#+END_SRC

*** Soft-indent stuff and hide stars for a cleaner look
#+BEGIN_SRC emacs-lisp
  (setq org-startup-indented t)
#+END_SRC

*** Edit src blocks in the current window instead of making a new split
#+BEGIN_SRC emacs-lisp
  (setq org-src-window-setup 'current-window)
#+END_SRC
** Markdown Mode
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (("README\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :config
    ;; Enable and configure wikilinks following behavior
    (setq markdown-enable-wiki-links t)
    (setq markdown-wiki-link-search-subdirectories t)
    (setq markdown-wiki-link-search-parent-directories t)
    ;; By default, it converts [[Foo Bar]] to Foo_Bar when following links—don't
    ;; do that.
    (setq markdown-link-space-sub-char " ")
    ;; Hide all formatting markdup
    (setq-default markdown-hide-urls t)
    )

  ;; Enable markdown mode for all files in zettel-dir
  (add-to-list 'auto-mode-alist `(,(concat "^" gw/zettel-dir-truename) . markdown-mode))

  ;; Mimic org-mode's adaptive bulleted list wrapping
  (add-hook 'markdown-mode-hook 'adaptive-wrap-prefix-mode)

  ;; Enable inline images by default
  (add-hook 'markdown-mode-hook 'markdown-toggle-inline-images)
#+END_SRC

** Custom gw/prose-mode and gw/centered-code-mode
#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :diminish
    :ensure t)

  (define-minor-mode gw/prose-mode
    "A nicely formatted writing environment."
    :lighter nil

    ;; Use a nice, prose-friendly font
    (setq buffer-face-mode-face '(:family "iA Writer Quattro V" :height 150))
    (buffer-face-mode)

    ;; Keep text in a centered column regardless of frame width
    (olivetti-mode)
    (olivetti-set-width 60)

    ;; Other UI niceties (Please keep these buffer-local, so we don't affect code
    ;; buffers in the same frame)
    (setq left-fringe-width 0 right-fringe-width 0)
    (setq line-spacing 4))

  (add-hook 'markdown-mode-hook 'gw/prose-mode)
  (add-hook 'org-mode-hook 'gw/prose-mode)


  (define-minor-mode gw/centered-code-mode
    "Keep code front and center."
    :lighter nil
    (olivetti-mode)
    (olivetti-set-width 120))

  (add-hook 'prog-mode-hook 'gw/centered-code-mode)
#+END_SRC


* Indentation / tabs
** Never use tabs
#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

** Display tabs as 4 spaces wide
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

** Use dtrt-indent to auto-detect indentation in some modes
When enabled as a minor mode, it will transparently try to set the indentation offset and `indent-tabs-mode` if it confidently detect what the currently-edited file is doing. It's source code is well-documented-just read it if you're having trouble.
#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :diminish
    :defer t
    :init
    (add-hook 'prog-mode-hook 'dtrt-indent-mode)
    :config
    (setq dtrt-indent-verbosity 2))
#+END_SRC

    :config
    (setq dtrt-indent-verbosity 2)
    (dtrt-indent-mode t))
#+END_SRC


* Editing/Selecting Text
** Use "C-=": expand-region for easy semantic highlighting
This is the only non-Vim way I can live without "cib" and friends
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :bind ("C-=" . er/expand-region))
#+END_SRC

** Use "M-z" to zap up UNTIL char instead of also killing the char
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-z") 'zap-up-to-char)
#+END_SRC

** Auto-insert the other half of a pair
#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
  (setq-default electric-pair-preserve-balance nil)
#+END_SRC

** Don't allow invisible edits in Org mode
It's easy to accidentally edit across folds--throw an error.
#+BEGIN_SRC emacs-lisp
  (setq org-catch-invisible-edits t)
#+END_SRC

** Make "C-e"/"C-a" heading-aware
#+BEGIN_SRC emacs-lisp
  (setq org-special-ctrl-a/e t)
#+END_SRC

** Bind "C-i" to go to beginning of text on line
#+BEGIN_SRC emacs-lisp
  ;; Decouple C-i from TAB and C-m from RET
  ;; NB: This will only work in GUI Emacs
  (define-key input-decode-map [?\C-m] [C-m])
  (define-key input-decode-map [?\C-i] [C-i])

  (global-set-key (kbd "<C-i>") 'beginning-of-line-text) ; Why do the angle brackets matter here?
#+END_SRC

** Use multiple-cursors
#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :init
    (setq-default mc/always-repeat-command t mc/always-run-for-all t)
    :bind (("C->" . mc/mark-next-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C-c C->" . mc/mark-all-like-this)
           ("C-S-<mouse-1>" . mc/add-cursor-on-click)))
#+END_SRC
** Use `hungry-delete` to kill extra whitespace
#+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :diminish
    :ensure t
    :config
    (global-hungry-delete-mode))
#+END_SRC


* Languages
** YAML
*** Install yaml-mode
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :mode "\\.ya?ml\\'")
#+END_SRC

** Ruby
*** Don't insert "coding: utf-8" magic comment
#+BEGIN_SRC emacs-lisp
  (setq ruby-insert-encoding-magic-comment nil)
#+END_SRC


* Linting
** Set up Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :init (add-hook 'prog-mode-hook 'flycheck-mode)
    :config
    (setq flycheck-check-syntax-automatically '(save mode-enabled))
    )

  (defun gw/use-pay-server-rubocop ()
    "Try to use pay-server's rubocop script if available."
    (let* ((root (locate-dominating-file
                  (or (buffer-file-name) default-directory)
                  "scripts/bin/rubocop"))
           (rubocop (and root
                        (expand-file-name "scripts/bin/rubocop"
                                          root))))
      (when (and rubocop (file-executable-p rubocop))
        (setq-local flycheck-ruby-rubocop-executable rubocop))))

  (add-hook 'flycheck-mode-hook #'gw/use-pay-server-rubocop)
#+END_SRC


* Autocomplete
** "M-/": hippie-expand instead of dabbrev-expand
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-/") 'hippie-expand)
#+END_SRC

** Configure Irony for C, C++, ObjC
** Configure Company and Company-Irony
#+BEGIN_SRC emacs-lisp
  (use-package company
    :diminish
    :defer t  ; Needed b/c we're not using any of the implicit defer macros
    :init (add-hook 'prog-mode-hook 'company-mode)  ; Load when activating a programming language mode
    :config
    (setq company-idle-delay 0.2)           ; In seconds--default is 0.5
    (setq company-dabbrev-downcase nil)     ; Don't downcase completions in plaintext/comments
    (setq company-dabbrev-ignore-case nil)  ; Respect the case of what I've already typed when suggesting completions
    ;; TAB to select candidate
    (bind-key "<tab>" 'company-complete-selection company-active-map)
    ;; Don't complete on <enter>, just input a newline
    (unbind-key "<return>" company-active-map)
    (unbind-key "RET" company-active-map)
    ;; Don't show location on <C-w>, kill word as normal
    (unbind-key "C-w" company-active-map)
    ;; Disable company-search-candidates so I can search in buffer when company is active
    (unbind-key "C-s" company-active-map)
    (unbind-key "C-r" company-active-map))
#+END_SRC
NB: successful completion of stuff in shared project header files requires setting `company-clang-arguments` (preferably in a .dir-locals.el) at project root to tell company about your header files for that project. For example:

`((nil . ((company-clang-arguments . ("-I/Users/grantwu/Code/git/lang/lilc/lib/")))))`

(I'm not putting it in a code block b/c I don't want this to be run on startup)

Read more about directory-local variables [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Directory-Variables.html][here]].


* Files / Buffers / Windows
** Use interactive buffer menu instead of default one
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Switch focus to new help buffers for easier <q> quitting
#+BEGIN_SRC emacs-lisp
  (setq-default help-window-select t)
#+END_SRC

** Init windmove keybindings (Ctrl+Shift+<direction>)
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-b") 'windmove-left)
  (global-set-key (kbd "C-S-f") 'windmove-right)
  (global-set-key (kbd "C-S-p") 'windmove-up)
  (global-set-key (kbd "C-S-n") 'windmove-down)
#+END_SRC

** Custom function to delete the current buffer and file
#+BEGIN_SRC emacs-lisp
  (defun gw/delete-current-buffer-and-file ()
    "Kill the current buffer and delete the file it's visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (when filename
        (if (vc-backend filename)
            (vc-delete-file filename)
          (progn
            (delete-file filename)
            (message "Deleted file %s" filename)
            (kill-buffer))))))
#+END_SRC
** Custom function to rename the current buffer and file
#+BEGIN_SRC emacs-lisp
  (defun gw/rename-current-buffer-and-file ()
    "Rename the current buffer and file it is visiting."
    (interactive)
    (let ((filename (buffer-file-name)))
      (if (not (and filename (file-exists-p filename)))
          (rename-buffer (read-from-minibuffer "New name: " (buffer-name)))
        (let* ((new-name (read-from-minibuffer "New name: " filename))
               (containing-dir (file-name-directory new-name)))
          (make-directory containing-dir t)
          (cond
           ((vc-backend filename) (vc-rename-file filename new-name))
           (t
            (rename-file filename new-name t)
            (set-visited-file-name new-name t t)))))))
#+END_SRC
** Init winner-mode to remember window configurations
C-c <left> to move down configuration stack
C-c <right> to jump to top of configuration stack
#+BEGIN_SRC emacs-lisp
  (use-package winner
    :config
    (setq winner-boring-buffers '("*Completions*"
                                  "*Compile-Log*"
                                  "*inferior-lisp*"
                                  "*Fuzzy Completions*"
                                  "*Apropos*"
                                  "*Help*"
                                  "*cvs*"
                                  "*Buffer List*"
                                  "*Ibuffer*"
                                  ))
    (winner-mode 1))
#+END_SRC
** Set up auto-insert
#+BEGIN_SRC emacs-lisp
  (use-package autoinsert
    :config
    (auto-insert-mode 1)
    (setq auto-insert-query nil)
    (setq auto-insert-alist '())
    (add-hook 'find-file-hook 'auto-insert))
#+END_SRC
** Remap C-x C-s to save all file-visiting buffers w/o prompting
#+BEGIN_SRC emacs-lisp
  (defun gw/save-all-buffers ()
    "Save all file-visiting without any prompting."
    (interactive)
    (save-some-buffers t))

  (global-set-key (kbd "C-x C-s") 'gw/save-all-buffers)
#+END_SRC


* Point
** Save point location across sessions
#+BEGIN_SRC emacs-lisp
  (save-place-mode)
#+END_SRC


* Searching / Navigation
** Faster highlighting with incremental search
#+BEGIN_SRC emacs-lisp
  (setq lazy-highlight-initial-delay 0.05)
#+END_SRC
** More extensive apropos search
#+BEGIN_SRC emacs-lisp
  (setq apropos-do-all t)
#+END_SRC

** Show current match/total in modeline with isearch
#+BEGIN_SRC emacs-lisp
  (use-package anzu
    :diminish
    :config (global-anzu-mode))
#+END_SRC

** C-': Avy for "easymotion" behavior
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind
    ("C-'" . avy-goto-word-1)
    :config
    (setq avy-background t))  ; Grey background when displaying results
#+END_SRC
** Use Ivy, Swiper, and Counsel for minibuffer stuff
In MELPA, Ivy and Swiper are included as dependencies of Counsel, so we just have to install the latter.
Ivy provides a generic narrowing interface similar to (but simpler than) Helm. Swiper and Counsel both use Ivy--Swiper replaces `isearch`, and Counsel replaces most of the common minibuffer search interfaces--see below.
#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :diminish ivy-mode
    :config       ; Stuff that only has meaning after package is loaded (possibly deferred)
    (ido-mode 0)  ; Disable Ido
    (ivy-mode 1)  ; Enable Ivy
    (setq ivy-use-virtual-buffers t)       ; Include recent files and bookmarks in ivy-switch-buffer
    (setq counsel-find-file-ignore-regexp  ; Ignore stuff in find-file
          (concat  ; NB all backslashes must be double-escaped
           ;; Beginning with . or #
           "\\(?:\\`[#.]\\)"
           ;; Ending with ~ or #
           "\\|\\(?:[#~]\\'\\)"
           ;; Ending with .out
           "\\|\\(?:\\.out\\'\\)"
           ;; Ending with .dSYM/
           "\\|\\(?:\\.dSYM/\\'\\)"
           ;; __pycache__/
           "\\|\\(?:__pycache__/\\'\\)"
           ;; node_modules/
           "\\|\\(?:node_modules/\\'\\)"
           ))
    (setq ivy-re-builders-alist
          '((t . ivy--regex-plus)))  ; Multi-word non-fuzzy regex matching
    (add-to-list 'ivy-height-alist '(counsel-rg . 15)) ; Display more results
    (setq counsel-rg-base-command "rg --case-sensitive --no-heading --line-number --color never %s .") ; Add --max-columns if this gets slow
    :bind
    ("C-x C-f" . counsel-find-file)     ; Respects counsel-find-file-ignore-regexp
    ("C-S-s" . counsel-grep-or-swiper)  ; Replace redundant forward-isearch binding with swiper
    ("C-M-r" . ivy-resume)              ; Replace isearch-backward-regexp with "resume most recent ivy search"
    ("C-M-s" . counsel-rg)              ; Replace isearch-forward-regexp with ripgrep
    ("M-x" . counsel-M-x)               ; Shows keybindings in results
    ("C-x b" . ivy-switch-buffer)       ; Otherwise, uses normal non-ivy minibuffer until you M-x ivy-switch-buffer manually, once
    ("<f1> f" . counsel-describe-function)   ; Highlights interactive functions
    ("<f1> v" . counsel-describe-variable))  ; Highlights defcustoms
#+END_SRC
Other Nice Keybindings
- When any Ivy buffer is open, M-n (next history element) will populate the search with the thing at point

** Use Projectile for project management
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind-keymap
    ;; I'd just C-c C-p here but markdown-mode uses that for useful navigation
    ;; stuff
    ("C-c p" . projectile-command-map)
    :config
    (setq projectile-completion-system 'ivy)
    (setq projectile-track-known-projects-automatically nil)  ; Don't auto-detect projects--it's noisy
    ;; Annoying by default—set in .projectile config for large projects
    ;; (setq projectile-enable-caching t)
    (projectile-mode))  ; Enable projectile-mode globally
#+END_SRC

** C-x f: Open recent file instead of set-fill-column
When used with C-u prefix arg, prompts for directory under which to search
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x f") 'counsel-recentf)
#+END_SRC

** Use `wgrep` for bulk find-replace
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t)
#+END_SRC


* VC / Diffing


* Generic Keybindings / Custom Functions
** Emacs
*** Edit this file
#+BEGIN_SRC emacs-lisp
  (defun gw/edit-config ()
    (interactive)
    (find-file "~/.emacs.d/conf.org"))
#+END_SRC
*** Enable M- commands like M-h (highlight paragraph)
#+BEGIN_SRC emacs-lisp
  (setq mac-pass-command-to-system nil)
#+END_SRC
*** Swap Meta and Super so Meta is closer to thumb
#+BEGIN_SRC emacs-lisp
  (setq mac-command-modifier 'meta)
  (setq mac-option-modifier 'super)
#+END_SRC
*** C-h: Backspace
Use <f1> to access help menus instead.
#+BEGIN_SRC emacs-lisp
  ;; Use key-translation-map to override any "C-h" bindings that any major or minor mode tries to introduce.
  (define-key key-translation-map (kbd "C-h") (kbd "<DEL>"))
#+END_SRC
*** C-w: Kill backwards word if region is not active
Since this uses `global-set-key` it can be overridden.
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-region-or-word (arg)
      "When called interactively with no region, kill a word backwards."
    (interactive "*p")
    (if (and transient-mark-mode
             mark-active)
        (kill-region (region-beginning) (region-end))
      (backward-kill-word arg)))

  (global-set-key (kbd "C-w") 'gw/kill-region-or-word)
#+END_SRC

*** M-<backspace>: Kill line backwards to indent
M-<backspace> kills backwards word by default, but that's duplicated by C-<backspace>, and also C-w above.
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-line-backwards-and-indent ()
    (interactive)
    (kill-line 0)
    (indent-according-to-mode))

  (global-set-key (kbd "M-<backspace>") 'gw/kill-line-backwards-and-indent)
#+END_SRC
*** s-a: Move to first char in line
Don't need to corresponding s-e b/c we should never have trailing whitespace
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "s-a") 'beginning-of-line-text)
#+END_SRC
*** C-x k: Kill current buffer without asking anything
#+BEGIN_SRC emacs-lisp
  (defun gw/kill-current-buffer ()
    "Kill the current buffer without prompting."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key (kbd "C-x k") 'gw/kill-current-buffer)
#+END_SRC

*** M-o: Focus other window
Default: add or remove faces to text in region
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-o") 'other-window)
#+END_SRC

*** Switch windows when splitting
#+BEGIN_SRC emacs-lisp
  ;; (defun gw/split-window-below-and-switch ()
  ;;   "Split window horizontally below and switch to new frame."
  ;;   (interactive)
  ;;   (split-window-below)
  ;;   (other-window 1)
  ;;   (balance-windows))

  ;; (defun gw/split-window-right-and-switch ()
  ;;   "Split window vertically to the right and switch to new frame."
  ;;   (interactive)
  ;;   (split-window-right)
  ;;   (other-window 1)
  ;;   (balance-windows))

  ;; (global-set-key (kbd "C-x 2") 'gw/split-window-below-and-switch)
  ;; (global-set-key (kbd "C-x 3") 'gw/split-window-right-and-switch)
#+END_SRC

*** "alt -" and "alt _": Insert en- and em-dashes
#+BEGIN_SRC emacs-lisp
  (defun gw/insert-em-dash ()
    "Inserts an EM-DASH (not a HYPHEN, not an M-DASH)"
    (interactive)
    (insert "—"))

  (defun gw/insert-en-dash ()
    "Inserts an EN-DASH (not a HYPHEN, not an N-DASH)"
    (interactive)
    (insert "–"))

  (global-set-key (kbd "s-_") 'gw/insert-em-dash)
  (global-set-key (kbd "s--") 'gw/insert-en-dash)
#+END_SRC

** Org Mode
*** <el: Elisp source block template
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
               '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC


* Custom Modes
** gw/zettel-mode
#+BEGIN_SRC emacs-lisp
  ;;; Backlink generation

  ;;; Code:
  (defun gw/all-notes-w-mtimes (dir)
    "Get a list of (filename . mtime) pairs.
  Searches the given DIR for files that start with a capital letter.
  Output format: ((<abs-note-path> . (int int int int)) (<abs-note-path> . (int int int int)))"
    (mapcar
     (lambda (file_and_attr)
       (cons
        (car file_and_attr)
        (file-attribute-modification-time (cdr file_and_attr))))
     (directory-files-and-attributes dir t "^[A-Z]"))) ; `t' returns abs paths

  (defun gw/outbound-links (note-abspath)
    "Get all unique outbound (above `# Backlinks`) links for a note.
  Returns: (\"Memex\" \"Activities\"), or nil if no outbound links."
    (with-temp-buffer
      (insert-file-contents note-abspath)
      (goto-char (point-max))
      (search-backward "# Backlinks" nil t)

      (let ((res))
        (while (re-search-backward "\\[\\[\\(.+\\)\\]\\]" nil t)
          ;; add-to-list already dedups entries
          (add-to-list 'res (match-string-no-properties 1)))
        res)))

  ;;; How This Works:
  ;; - Get a list of all notes and their mtimes, as a list of (<abs-path> . (int int int int)) pairs
  ;; - For each note, get the outbound links, and put them in a {link-shortname: (abs-backlink abs-backlink)} hash
  ;; - For each note, look its shortname up in the hash to find its backlinks, and insert a wikilink for each of them
  ;;
  ;; Invariants:
  ;; - "# Backlinks" must be the last section in every note
  ;; - gw/gen-backlinks assumes all note buffers have been saved—it doesn't check or ask before modifying the underlying files.

  (defun gw/gen-backlinks ()
    "Get a map of target_note: [notes_that_link_target_note]."
    (message "Starting backlink generation.")
    (let ((res (make-hash-table :test #'equal))
          (notes (gw/all-notes-w-mtimes gw/zettel-dir)))
      (mapc
       (lambda (note)
         (mapc
          (lambda (link-target)
            (puthash
             link-target
             (append (gethash link-target res ()) (list (car note)))
             res))
          (gw/outbound-links (car note))))
       notes)

      (mapc
       (lambda (note)
         (let ((modified nil))
           ;; Adapted from https://wilkesley.org/~ian/xah/emacs/elisp_idioms_batch.html
           (with-temp-buffer
             (insert-file-contents (car note))
             (goto-char (point-max))

             ;; Clear out existing backlinks, if any.
             (when (search-backward "# Backlinks" nil t)
               (delete-region (point) (point-max))
               (delete-trailing-whitespace)
               (setq modified t))

             (let ((linkers (gethash (file-name-base (car note)) res)))
               (if linkers
                   (progn
                     (insert "\n# Backlinks\n")
                     (mapc
                      (lambda (linker)
                        (insert (format "- [[%s]]\n" (file-name-base linker))))
                      linkers)
                     (setq modified t))))
             (when modified
               ;; Doesn't run save-hooks. We probably could but it seems safer to not.
               (write-region 1 (point-max) (car note))
               ;; Pretend we didn't touch the file (preserves mtime-based ordering
               ;; in gw/all-notes)
               (set-file-times (car note) (cdr note))))))
       notes)))


  ;;; Zettelkasten helper methods

  (defun gw/all-notes ()
    "Get a list of all notes."
    (mapcar 'file-name-base
            (split-string
             (shell-command-to-string
              ;; -t sorts by mtime, then we exclude assets/
              (format "ls -t %s | rg --invert-match assets" gw/zettel-dir))
             "\n")))

  (defun gw/all-tags ()
    "Get a list of all tags."
    (delete-dups
     (split-string
      (shell-command-to-string
       ;; -o: Print only the matching parts of a matching line
       (format "rg -g '!assets' -o --no-heading --no-filename --no-line-number \"#\\w+\" %s" gw/zettel-dir)))))

  (defun gw/insert-wikilink ()
    "Select a note and insert wikilink to it."
    (interactive)
    (ivy-read "Select note: "
              (gw/all-notes)
              :action (lambda (note)
                        (insert (format "[[%s]]" note)))))

  (defun gw/insert-tag ()
    "Select a tag and insert it."
    (interactive)
    (ivy-read "Select tag: "
              (gw/all-tags)
              :action
              (lambda (tag)
                (insert tag))
              ;; Can use this if I install ivy-hydra to mark multiple candidates
              ;; :multi-action
              ;; (lambda (tags)
              ;;   (insert (string-join tags " ")))
              ))

  (defun gw/regexp-list (regex string)
    "Return a list of all REGEXP matches in STRING."
    ;; source: http://emacs.stackexchange.com/questions/7148/get-all-regexp-matches-in-buffer-as-a-list
    (let ((pos 0)        ; string marker
          (matches ()))  ; return list
      (while (string-match regex string pos)
        (push (match-string 0 string) matches)
        (setq pos (match-end 0)))
      (setq matches (reverse matches))
      matches))

  (defun gw/munged-filename ()
    "Get the buffer's filename, with capitalized words separated by spaces."
    (file-name-base buffer-file-name))

  (defun gw/insert-note-template ()
    "Insert a markdown heading with a formatted version of the buffer's filename."
    (insert (format "# %s" (gw/munged-filename))))

  (defun gw/open-or-create-note ()
    "Open or create a note in the zettel-dir."
    (interactive)
    (ivy-read "Open note: "
              (gw/all-notes)
              :action (lambda (note)
                        (find-file (format "%s%s.txt" gw/zettel-dir-truename note)))))

  ;; Allow binding stuff to C-z, which is normally non-prefix
  (define-key global-map (kbd "C-z") (make-sparse-keymap))
  (global-set-key (kbd "C-z C-n") 'gw/open-or-create-note)

  (define-minor-mode gw/zettel-mode
    "Zettelkasten conveniences."
    :lighter " Z"
    :keymap (let ((map (make-sparse-keymap)))
              (define-key map (kbd "C-z n") 'gw/insert-wikilink)
              (define-key map (kbd "C-z t") 'gw/insert-tag)
              (define-key map (kbd "<down>") 'markdown-next-link)
              (define-key map (kbd "<up>") 'markdown-previous-link)
              (define-key map (kbd "<left>") 'previous-buffer)
              (define-key map (kbd "<right>") 'markdown-follow-thing-at-point)
              (define-key map (kbd "C-x C-s") (lambda ()
                                                (interactive)
                                                (gw/save-all-buffers)
                                                (gw/gen-backlinks)))
              map))

  ;; Insert boilerplate when opening new files in markdown-mode
  ;; TODO This ideally is predicated on gw/zettel-mode, but auto-insert
  ;; only checks the major mode, so we'd have to hack auto-insert.
  (define-auto-insert 'markdown-mode 'gw/insert-note-template)

  ;; Enable zettel-mode when opening a file in the zettel-dir
  ;; There's no minor-mode equivalent to auto-mode-alist, so we hack one here.
  (add-hook 'find-file-hook
            (lambda ()
              (when (string= (file-name-directory buffer-file-name) gw/zettel-dir-truename)
                (gw/zettel-mode))))
#+END_SRC


* History
** Persist kill-ring, isearch queries, and other minibuffer stuff across sessions
#+BEGIN_SRC emacs-lisp
  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-delete-duplicates t)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))
#+END_SRC


* Useful Info
** global-set-key vs define-key
Use the former to define a global keymapping, use the latter to define a mapping for a particular mode, like so: `(define-key c-mode-base-map (kbd "C-c t") 'myfunc)`.

`c-mode-base-map` applies to all languages that cc-mode supports, whereas `c-mode-map` applies to just the C language.

`key-translation-map` is a lower-level mapping that basically modifies what keystrokes Emacs sees. `global-set-key` mappings are overridden by minor mode mappings--`key-translation-map` mappings are not.


* Setting Emacs up on a new machine
- Download ripgrep
- brew install railwaycat/emacs
- git clone the appropriate emacs source and make sure it matches `find-function-C-source-directory`


* Stuff for future
** Memex Features
** Features
*** KBD shortcut to open the current line in github
*** Write function to highlight everything at current indentation (v i i) in VSCode
...and write one to highlight the boundary lines as well (v a i)
*** Fix indentation when chaining Ruby method calls on multiple lines
*** Highlight search term in occur buffers (C-c C-o in counsel-rg results)
*** Have "C-w" just kill backwards word in isearch, and bind something else to "yank next word in buffer and add to search"
*** Why is editing HTML so slow? Learn how to debug emacs perf and figure out what's causing intermittent typing lag
*** Use something fast (fd?) to generate Projectile candidates so quickly that we don't actually need to cache it
*** Map C-x C-s to save all modified buffers that you actually care about
*** Learn and set up Dired
*** Learn and set up Magit
*** Make company autcomplete fuzzy-match and rank by recent usage
*** Use full file path name in 'ivy-switch-buffer so you can better disambiguate
*** Change 'mark-defun to include sig annotations that appear above the function
*** Figure out why C-S-p doesn't register in the OS when pressed with the enter key as ctrl
*** Figure out why the heck M-? is so slow in pay-server
Profile out, and make it faster
*** Have annotate-annotate just write eagerly to the annotations file, instead of touching the buffer and writing when the buffer gets saved. Should be totally transparent to the buffer itself
*** Have 'vc-annotate try to use the biggest split that's closest to the blaming split
Not a tiny horizontal split on the other side of the frame
*** Projectile find file won't open files if invoked via 'ivy-resume and the target file isn't already open
*** Test runner framework with a context, like current-filename
- Plus a function to counsel-search b/w recently-run tests, which defaults to the most recently-run test
*** Swiper doesn't reset font faces in *xref* buffers
*** Write analogue of gw/delete-current-buffer-and-file that renames current buffer and file
*** Improve IBuffer to show longer filenames
*** Write comma-separated items (within a paren or list or other delimiter)
*** Run ripper-tags on git hooks
*** Get Sorbet in Emacs
*** Pay-server rubocop errors (things that fail builds) show up as "info" in Flycheck. Make them show up as errors!
Idea--delete the projectile cache on a git hook
*** Update projectile's cache in the background, async, after any git actions
*** Make C-v and M-v set the mark, but not on subsequent invocations of C-v or M-v
*** Fast find/replace in file / region / directory / project
*** Function to toggle between last focused window and current window
*** Modify counsel-file-jump to use ripgrep, or find another method for finding a file under a non-project directory
*** Show search directory in prompt of counsel-rg
*** Get S-SPC working in Ivy (start a new search where the files being searched are those in the current candidates list)
*** Magit-like interface into Ivy/Counsel that makes it easy to toggle case-sensitiviy
*** Figure out how to change keybindings on particular contexts, e.g. ivy minibuffer (bind S-SPC to ivy-restrict-to-matches) and when autocomplete menu is visible (bind C-w to still be backwards kill word instead of showing documentation)
*** Disable bold fonts after init, so it actually works (after everything else loads)
*** Disable autocompletion in comments
*** Show full file path and Major mode in status line, and nothing else
*** Understand and install visual-fill-column
*** Highlight all occurrences of region across buffers
Either with a keyboard shortcut or automatically whenever the region is active

*** Navigate global mark ring forwards and backwards, and make it work across files
https://stackoverflow.com/questions/3393834/how-to-move-forward-and-backward-in-emacs-mark-ring
*** Start fuzzy finding in dir from counsel-find-file or dired
*** Grep in open/recent buffers
*** Fast grep entire project for symbol, while tuning case sensitivity and whole-word-ness
- Basically replicating Sublime search in emacs
- Also: preserve search results in a buffer so you can go back to them without re-running the search
*** Show all class/method/function/constant definitions in a file, regardless of language (Sublime cmd-r)
*** Make <tab> and <backtab> just insert tabs, and bind something else to 're-indent'
...and also automatically re-indent when yanking lines
...and also fix weird indenting behavior when entering new lines in param lists
*** Figure out the best way to test and then replace regexes in file AND project
*** Ruby IDE
- Rubocop linting
- rippertags company
*** Make I-search auto-wrap
https://stackoverflow.com/questions/285660/automatically-wrapping-i-search
*** Install indent guide package
*** Execute this script on init to disable all bold fonts
(mapc
   (lambda (face)
     (set-face-attribute face nil :weight 'normal))
   (face-list))
*** Get commenting with M-; to work in Org-mode code snippets
*** Automatically update Projectile cache when a new file gets created
*** Persistent undo to cache dir

** Bugs
*** counsel-rg doesn't always put the highlight on the last-viewed search result when M-p'ing to recent searches
*** Invoking C-r projectile-find-file results in an empty list, because it doesn't call ivy with a :history. Should use C-c p e instead but I wonder if we could somehow bind that to C-r when invoked inside of C-c p f
*** counsel-file-jump and counsel-find-file share the same reverse-i-search history, which borks because they're incompatible
Prob give counsel-file-jump its own history cuz file-name-history appears to be shared by lots of built-in emacs stuff
*** ivy--regex-plus "!" operator doesn't work with counsel-{ag, rg}
It's just treated as another search term
https://github.com/abo-abo/swiper/blob/master/doc/ivy.org#ivyregex-plus
*** Ivy results highlight case-insensitively even if ivy-case-fold-search-default is nil


* How To Do Stuff in Emacs
** Elisp
*** How Elisp Works
Lisp is simple. Everything is s list. All lists are ready-to-run programs. All lists are data--sequences of atoms separated by whitespace. All the interpreter does is:
  1) Check if there's a quote before the list. If so, it just gives the list back to you.
  2) If not, it looks for a function definition by the name of the first element. If it finds one, it first evaluates any contained lists and then executes the function. If it doesn't, it prints an error message.
  3) If it's a symbol that's not in a list, treat it as a variable.

*** Symbols can be used as variables AND functions
In `(+ 3 3)`, '+' is treated as a function b/c it's the first element of a list.
In `+`, '+' is treated as a variable--evaluating this will result in a void-variable error
Symbols can be used as both--think of them as a chest with two drawers. In one, you can put a function definition--in the other, you can put a varying value. The two don't affect each other.
*** cons vs car vs cdr
Note: All are non-mutating

cons: Short for "construct"
  - Returns a list with an element pushed onto the beginning of a list
(cons 'pine '(fir oak maple))
-> (pine fir oak maple)

car:  Acronym for "Contents of Address part of Register"
  - The CAR of a list is the first item in the list
  - Could be called "first"
(car '(fir oak maple))
-> fir

cdr:  Acronym for "Contents of Decrement part of Register"
  - The CDR of a list is a list containing everything after the first item in the list
  - Could be called "rest"
(cdr '(fir oak maple))
-> (oak maple)

Holdovers from original Lisp machines, have been obsolete for years

** Quick Text Manipulation
*** Repeat last command
From `repeat.el`, now standard in Emacs
"C-x z", and then "z" to keep repeating it after that
If the command used the minibuffer you'll have to keep providing input
*** Highlight Paragraph over point
M-h
*** Reflow paragraph over point
M-q
*** Undo only in region
C-u C-/

** Bulk Text Manipulation
*** Show all regexp matches in a file
M-x occur

*** Replace all string/regexp matches in a file
string: M-% aka M-x query-replace
Regexp: C-M-% aka M-x query-replace-regexp

Both can be tested with C-s, isearch-forward-regexp, to test your regexp. When it looks right just press M-% and go (it's smart enough to know that you want query-replace-regexp if you invoke it from isearch-forward-regexp)
These regexes are pretty powerful. Use '\(\)' in the regex to specify capture groups.
Replacement text has:
- \& the matched string
- \1, \2 numbered capture groups
- \# the number of matched lines so far
- \? prompt user for what to enter at each replacement
- \, arbitrary (lisp expression)

*** Replace all string-regexp matches in project
projectile-find-replace and projectile-find-replace-regexp
or;
the builtin project-find-regexp
or
counsel-rg, then C-x C-q to enable wrep, standard query-replace, then save the wgrep buffer

*** Run shell command on region, replacing it with output
Highlight region and do:
M-|
With a prefix arg it replaces the region with the output of the shell command

*** Turn on hard line wrapping for a buffer
aka have Emacs insert newline characters automatically, a la "fill-region".
Just enable 'auto-fill-mode. This will insert newline characters at 'fill-column
as you type.

** Navigation
*** Setting a persistent place to jump back to
Two options: Registers and Bookmarks

Registers:
Named by single-letter "key"s, don't persist across Emacs sessions. Good for quickly saving locations related to your current task, but which you probably won't need to remember later.

Save position of point to a register named by "key"
C-x r <SPC> "key"

Jump to the register named by "key". Can be in a different, unopened buffer.
C-x r j "key"

Bookmarks:
Named by arbitrary strings, do persist across Emacs sessions--when you exit Emacs any modified bookmarks will be persisted to bookmark-default-file, which defaults to ~/.emacs.d/bookmarks. Good for saving locations that you'll come back to frequently over the course of a project.

Save position of point to a bookmark named "name":
C-x r m "name"

Jump to a bookmark named "name". Can be in a different, unopened buffer.
C-x r b "name"

Delete a bookmark named "name"
(bookmark-delete)

List all bookmarks, annotate/modify them
C-x r l

*** Jumping back to where just were, after searching
C-u C-SPC
Move backwards through mark ring

** Layout
*** Toggle Fullscreen (railwaycat only)
Hold shift and pinch in/out
Executes `mac-mouse-turn-on-fullscreen`
*** Save a window configuration
Registers, again!
C-x r w "key"

Accessed just like any register:
C-x r j "key"
** Calling functions
*** Call interactive function with an argument
If an interactive function takes an argument, that argument comes from the prefix argument, which is best passed with <M-number> before calling <M-x> to find the function or using its keybinding.

To quickly call with a negative prefix argument, just do <M-->
** Info Mode
*** Navigation
**** Basic Navigation
- <?> show keybindings popup
These only progress through nodes at your current level
- <n> go to next node at current level, if any
- <p> go to prev node at current level, if any
- <l> go to last node you were just at (useful for coming back from distant xrefs)
- <r> opposite of <l>
These can progress through every node in the document
- <]> go to next child or node if no more children
- <[> go to last child of previous node

- <t> go to top of current manual
- <d> go back to Directory, which links to all manuals
**** Menu links and xrefs
- <TAB>, <S-TAB> cycle through *Menu items and xrefs in the node
- <m> open *Menu select dialogue for node
- <f> open xref dialogue for node
*** Searching
- <i> search the manual's index--<,> cycles through each match until you've found what you're looking for. This should be the first thing you search--commands, options, and key sequences should all be indexed.
  - <I> builds a virtual node with the results of the search
  - `info-apropos` searches across all indices of all manuals on your system
- <C-r>, <C-s> incremental search across the entire manual
- <g> go to a node in the manual by name
*** Windows
- <M-n> opens another, independent Info buffer (for going off on tangents)
